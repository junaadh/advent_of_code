// generated by GEN=1 cargo build
#[derive(Debug)]
pub struct AdventDay4 {
    pub day: utils::Day,
}

impl AdventDay4 {
    pub fn new() -> Box<Self> {
        Box::new(Self {
            day: utils::Day::Four,
        })
    }
}

impl utils::AocHelper for AdventDay4 {
    fn get_day(&self) -> utils::Day {
        self.day
    }
}

impl utils::AocDay for AdventDay4 {
    fn part1(&self, content: &str) -> usize {
        let grid = content
            .lines()
            .map(|x| x.chars().collect::<Vec<_>>())
            .collect::<Vec<_>>();
        let rows = grid.len();
        let cols = grid[0].len();

        let mut bools = Vec::new();

        for row in 0..rows {
            for col in 0..cols {
                'out: for dir in DIRECTONS {
                    for (i, char) in "XMAS".char_indices() {
                        let r = row as isize + (i as isize * dir.0);
                        let c = col as isize + (i as isize * dir.1);

                        let r = r as usize;
                        let c = c as usize;

                        if r >= rows || c >= cols || grid[r][c] != char {
                            continue 'out;
                        }
                    }
                    bools.push(true);
                }
            }
        }

        bools.iter().filter(|&x| *x).count()
    }

    fn part2(&self, content: &str) -> usize {
        let grid = content
            .lines()
            .map(|x| x.chars().collect::<Vec<_>>())
            .collect::<Vec<_>>();
        let rows = grid.len();
        let cols = grid[0].len();

        let mut res = Vec::new();

        for row in 0..rows {
            for col in 0..cols {
                res.push(if row > 0 && row + 1 < rows && col > 0 && col + 1 < cols {
                    grid[row - 1][col - 1] == 'M'
                        && grid[row - 1][col + 1] == 'S'
                        && grid[row][col] == 'A'
                        && grid[row + 1][col - 1] == 'M'
                        && grid[row + 1][col + 1] == 'S'
                        || grid[row - 1][col + 1] == 'M'
                            && grid[row - 1][col - 1] == 'S'
                            && grid[row][col] == 'A'
                            && grid[row + 1][col + 1] == 'M'
                            && grid[row + 1][col - 1] == 'S'
                        || grid[row - 1][col + 1] == 'S'
                            && grid[row - 1][col - 1] == 'S'
                            && grid[row][col] == 'A'
                            && grid[row + 1][col + 1] == 'M'
                            && grid[row + 1][col - 1] == 'M'
                        || grid[row - 1][col + 1] == 'M'
                            && grid[row - 1][col - 1] == 'M'
                            && grid[row][col] == 'A'
                            && grid[row + 1][col + 1] == 'S'
                            && grid[row + 1][col - 1] == 'S'
                } else {
                    false
                })
            }
        }

        res.iter().filter(|x| **x).count()
    }
}

const DIRECTONS: [(isize, isize); 8] = [
    (0, 1),
    (1, 0),
    (0, -1),
    (-1, 0),
    (1, 1),
    (1, -1),
    (-1, 1),
    (-1, -1),
];
