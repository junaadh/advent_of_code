use std::collections::HashSet;

// generated by GEN=1 cargo build
#[derive(Debug)]
pub struct AdventDay6 {
    pub day: utils::Day,
}

impl AdventDay6 {
    pub fn new() -> Box<Self> {
        Box::new(Self {
            day: utils::Day::Six,
        })
    }
}

impl utils::AocHelper for AdventDay6 {
    fn get_day(&self) -> utils::Day {
        self.day
    }
}

impl utils::AocDay for AdventDay6 {
    fn part1(&self, content: &str) -> usize {
        let (mut map, start, dir) = parse_map(content);
        // map.iter().for_each(|x| {
        //     x.iter().for_each(|y| print!("{y}"));
        //     println!()
        // });
        // let res =
        run_sim(&mut map, start, dir) //;
                                      // map.iter().for_each(|x| {
                                      //     x.iter().for_each(|y| print!("{y}"));
                                      //     println!()
                                      // });
                                      // res
    }

    fn part2(&self, content: &str) -> usize {
        let (map, start, dir) = parse_map(content);

        find_valid_obstructions(&map, start, dir)
    }
}

type Pos = (i64, i64);
type CharMap = Vec<Vec<char>>;

fn parse_map(buffer: &str) -> (CharMap, Pos, Pos) {
    let mut map = Vec::new();
    let mut start = (0, 0);
    let mut dir = (0, 0);

    for (row, line) in buffer.lines().enumerate() {
        let row = row as i64;
        let mut map_row = Vec::new();
        for (col, ch) in line.char_indices() {
            let col = col as i64;
            if "^v<>".contains(ch) {
                start = (row, col);
                dir = match ch {
                    '^' => (-1, 0),
                    '>' => (0, 1),
                    'v' => (1, 0),
                    '<' => (0, -1),
                    _ => unreachable!(),
                };
                map_row.push('X');
            } else {
                map_row.push(ch);
            }
        }
        map.push(map_row);
    }

    (map, start, dir)
}

fn turn(dir: Pos) -> Pos {
    match dir {
        (-1, 0) => (0, 1),  // Up -> Right
        (0, 1) => (1, 0),   // Right -> Down
        (1, 0) => (0, -1),  // Down -> Left
        (0, -1) => (-1, 0), // Left -> Up
        _ => unreachable!(),
    }
}

fn run_sim(map: &mut CharMap, start_pos: Pos, start_dir: Pos) -> usize {
    let mut visited = HashSet::new();
    let mut pos = start_pos;
    let mut dir = start_dir;

    visited.insert(pos);
    map[pos.0 as usize][pos.1 as usize] = 'X';

    let rows = map.len() as i64;
    let cols = map[0].len() as i64;

    loop {
        let (next_row, next_col) = (pos.0 + dir.0, pos.1 + dir.1);

        if next_row < 0 || next_row >= rows || next_col < 0 || next_col >= cols {
            break;
        }

        if map[next_row as usize][next_col as usize] == '#' {
            dir = turn(dir);
        } else {
            pos = (next_row, next_col);
            visited.insert(pos);
            map[pos.0 as usize][pos.1 as usize] = 'X';
        }
    }

    visited.len()
}

fn simulate(
    map: &[Vec<char>],
    start_pos: Pos,
    start_dir: Pos,
    obstruction: Option<Pos>,
) -> Option<HashSet<Pos>> {
    let mut visited_states = HashSet::new();
    let mut reachable_positions = HashSet::new();
    let mut pos = start_pos;
    let mut dir = start_dir;

    let rows = map.len() as i64;
    let cols = map[0].len() as i64;

    loop {
        if !visited_states.insert((pos, dir)) {
            return Some(reachable_positions);
        }

        reachable_positions.insert(pos);

        let (next_row, next_col) = (pos.0 + dir.0, pos.1 + dir.1);

        if next_row < 0 || next_row >= rows || next_col < 0 || next_col >= cols {
            if obstruction.is_some() {
                return None;
            } else {
                return Some(reachable_positions);
            }
        }

        if Some((next_row, next_col)) == obstruction
            || map[next_row as usize][next_col as usize] == '#'
        {
            dir = turn(dir);
        } else {
            pos = (next_row, next_col);
        }
    }
}

fn find_valid_obstructions(map: &[Vec<char>], start_pos: Pos, start_dir: Pos) -> usize {
    let reachable_positions = simulate(map, start_pos, start_dir, None).expect("Nope?");

    reachable_positions
        .into_iter()
        .filter(|&pos| pos != start_pos)
        .filter(|&pos| simulate(map, start_pos, start_dir, Some(pos)).is_some())
        .count()
}
